<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><link rel="stylesheet" href="dmdoc.css"><title>modular_skyrat/readme.md - /tg/ Station 13</title></head><body><header><a href="index.html">/tg/ Station 13</a> - <a href="index.html#modules">Modules</a> - <a href="index.html#types">Types</a></header><main><h1>The modularization handbook - Skyrat style, v0.2 <aside>modular_skyrat/readme.md</aside> <a href="https://github.com/Skyrat-SS13/Skyrat-tg/blob/e507f9120bb0c3beecfe169d14193d90e7229a58/modular_skyrat/readme.md0"><img src="git.png" width="16" height="16" title="modular_skyrat/readme.md0"></a></h1><table class="summary" cellspacing="0"><tr><td colspan="2"><h2 id="failure-to-follow-this-guide-will-result-in-your-pr-being-denied">Failure to follow this guide will result in your PR being denied.</h2><h2 id="introduction">Introduction</h2>
<p>To develop and maintain a separate codebase is a big task, that many have failed and suffered the consequences of, such as outdated, and messy code.
It's not necessarily the fault of lack of skill of the people maintaining it, merely the lack of resources and how much continuous effort such an endeavor takes.</p>
<p>One of the solutions for such, is to base our server on a solid codebase, that is primarily maintained by somebody else, in this case tgstation, and insert our content in a modular fashion, while following the general code (but not gameplay) direction of the upstream, mirroring any changes they do for parity.</p>
<p>Git, as a version control system, is very useful, however it is just a very methodical thing, that follows its many algorithms, that sadly cannot always intelligently resolve certain changes in the code in an unambiguous way, giving us conflicts, that need to be resolved in a manual fashion.</p>
<p>Due to maintainability being one of the main reasons behind our rebase to another codebase, <strong>this protocol will seriously be enforced.</strong>
A well organized, documented and atomized code saves our maintainers a lot of headache, when being reviewed.
Don't dump on them the work that you could have done yourself.</p>
<p>This document is meant to be updated and changed, whenever any new exceptions are added onto it. It might be worth it to check, from time to time, whether we didn't define a more unique standardized way of handling some common change.</p>
<h2 id="important-note-test-your-pull-requests">Important note - TEST YOUR PULL REQUESTS</h2>
<p>You are responsible for the testing of your content. You should not mark a pull request ready for review until you have actually tested it. If you require a separate client for testing, you can use a guest account by logging out of BYOND and connecting to your test server. Test merges are not for bug finding, they are for stress tests where local testing simply doesn't allow for this.</p>
<h3 id="the-nature-of-conflicts">The nature of conflicts</h3>
<p>For example, let's have an original</p>
<pre><code class="language-byond">var/something = 1
</code></pre>
<p>in the core code, that we decide to change from 1 to 2 on our end,</p>
<pre><code class="language-diff">- var/something = 1
+ var/something = 2 //SKYRAT EDIT
</code></pre>
<p>but then our upstream introduces a change in their codebase, changing it from 1 to 4</p>
<pre><code class="language-diff">- var/something = 1
+ var/something = 4
</code></pre>
<p>As easy of an example as it is, it results in a relatively simple conflict, in the form of</p>
<pre><code class="language-byond">var/something = 2 //SKYRAT EDIT
</code></pre>
<p>where we pick the preferable option manually.</p>
<h3 id="the-solution">The solution</h3>
<p>That is something that cannot and likely shouldn't be resolved automatically, because it might introduce errors and bugs that will be very hard to track down, not to even bring up more complex examples of conflicts, such as ones that involve changes that add, remove and move lines of code all over the place.</p>
<p>tl;dr it tries its best but ultimately is just a dumb program, therefore, we must ourselves do work to ensure that it can do most of the work, while minimizing the effort spent on manual involvement, in the cases where the conflicts will be inevitable.</p>
<p>Our answer to this is modularization of the code.</p>
<p><strong>Modularization</strong> means, that most of the changes and additions we do, will be kept in a separate <strong><code>modular_skyrat/</code></strong> folder, as independent from the core code as possible, and those which absolutely cannot be modularized, will need to be properly marked by comments, specifying where the changes start, where they end, and which feature they are a part of, but more on that in the next section.</p>
<h2 id="the-modularization-protocol">The modularization protocol</h2>
<p>Always start by thinking of the theme/purpose of your work. It's oftentimes a good idea to see if there isn't an already existing one, that you should append to.</p>
<p><strong>If it's a tgcode-specific tweak or bugfix, first course of action should be an attempt to discuss and PR it upstream, instead of needlessly modularizing it here.</strong></p>
<p>Otherwise, pick a new ID for your module. E.g. <code>DNA-FEATURE-WINGS</code> or <code>XENOARCHEAOLOGY</code> or <code>SHUTTLE_TOGGLE</code> - We will use this in future documentation. It is essentially your module ID. It must be uniform throughout the entire module. All references MUST be exactly the same. This is to allow for easy searching.</p>
<p>And then you'll want to establish your core folder that you'll be working out of which is normally your module ID. E.g. <code>modular_skyrat/modules/shuttle_toggle</code></p>
<h3 id="maps">Maps</h3>
<p>IMPORTANT: MAP CONTRIBUTION GUIDELINES HAVE BEEN UPDATED</p>
<p>When you are adding a new item to the map you MUST follow this procedure:
Start by deciding how big of a change it is going to be, if it is a small 1 item change, you should use the simple area automapper. If it is an entire room, you should use the template automapper.</p>
<p>We will no longer have _skyrat map versions.</p>
<p>DO NOT CHANGE TG MAPS, THEY ARE HELD TO THE SAME STANDARD AS ICONS. USE THE ABOVE TO MAKE MAP EDITS.</p>
<p>The automapper uses prebaked templates to override sections of a map using coordinates to plot the starting location. See entries in automapper_config.toml for examples.</p>
<p>The simple area automapper uses datum entries to place down a single item in an area of a map that makes vauge sense.</p>
<h3 id="assets-images-sounds-icons-and-binaries">Assets: images, sounds, icons and binaries</h3>
<p>Git doesn't handle conflicts of binary files well at all, therefore changes to core binary files are absolutely forbidden, unless you have a really <em>really</em> <em><strong>really</strong></em> good reason to do otherwise.</p>
<p>All assets added by us should be placed into the same modular folder as your code. This means everything is kept inside your module folder, sounds, icons and code files.</p>
<ul>
<li>
<p><em><strong>Example:</strong></em> You're adding a new lavaland mob.</p>
<p>First of all you create your modular folder. E.g. <code>modular_skyrat/modules/lavalandmob</code></p>
<p>And then you'd want to create sub-folders for each component. E.g. <code>/code</code> for code and <code>/sounds</code> for sound files and <code>/icons</code> for any icon files.</p>
<p>After doing this, you'll want to set your references within the code.</p>
<pre><code class="language-byond">  /mob/lavaland/newmob
    icon = 'modular_skyrat/modules/lavalandmob/icons/mob.dmi'
    icon_state = &quot;dead_1&quot;
    sound = 'modular_skyrat/modules/lavalandmob/sounds/boom.ogg'
</code></pre>
<p>This ensures your code is fully modular and will make it easier for future edits.</p>
</li>
<li>
<p>Other assets, binaries and tools, should usually be handled likewise, depending on the case-by-case context. When in doubt, ask a maintainer or other contributors for tips and suggestions.</p>
</li>
<li>
<p>Any additional clothing icon files you add MUST go into the existing files in master_files clothing section.</p>
</li>
</ul>
<h3 id="the-folder">The <code>master_files</code> Folder</h3>
<p>You should always put any modular overrides of icons, sound, code, etc. inside this folder, and it <strong>must</strong> follow the core code folder layout.</p>
<p>Example: <code>code/modules/mob/living/living.dm</code> -&gt; <code>modular_skyrat/master_files/code/modules/mob/living/living.dm</code></p>
<p>This is to make it easier to figure out what changed about a base file without having to search through proc definitions. </p>
<p>It also helps prevent modules needlessly overriding the same proc multiple times. More information on these types of edits come later.</p>
<h3 id="fully-modular-portions-of-your-code">Fully modular portions of your code</h3>
<p>This section will be fairly straightforward, however, I will try to go over the basics and give simple examples, as the guide is aimed at new contributors likewise.</p>
<p>The rule of thumb is that if you don't absolutely have to, you shouldn't make any changes to core codebase files. With some exceptions that will be mentioned shortly.</p>
<p>In short, most of the modular code will be placed in the subfolders of your main module folder <strong><code>modular_skyrat/modules/yourmodule/code/</code></strong>, with similar rules as with the assets. Do not mirror core code folder structures inside your modular folder.</p>
<p>For example, <code>modular_skyrat/modules/xenoarcheaology/code</code> containing all the code, tools, items and machinery related to it.</p>
<p>Such modules, unless <em>very</em> simple, <strong>need</strong> to have a <code>readme.md</code> in their folder, containing the following:</p>
<ul>
<li>links to the PRs that implemented this module or made any significant changes to it</li>
<li>short description of the module</li>
<li>list of files changed in the core code, with a short description of the change, and a list of changes in other modular files that are not part of the same module, that were necessary for this module to function properly</li>
<li>(optionally) a bit more elaborative documentation for future-proofing the code,  that will be useful further development and maintenance</li>
<li>credits</li>
</ul>
<p><em><strong>Template:</strong></em> <a href="module_template.md">Here</a></p>
<h2 id="modular-overrides-important">Modular Overrides (Important!!)</h2>
<p>Note, that it is possible to append code in front, or behind a core proc, in a modular fashion, without editing the original proc, through referring the parent proc, using <code>. = ..()</code> or <code>..()</code>. And likewise, it is possible to add a new var to an existing datum or obj, without editing the core files.</p>
<p><strong>Note about proc overrides: Just because you can, doesn't mean you should!!</strong></p>
<p>In general they are a good idea and encouraged whenever it is possible to do so. However this is not a hard rule, and sometimes Skyrat edits are preferable. Just try to use your common sense about it.</p>
<p>For example: please do not copy paste an entire TG proc into a modular override, make one small change, and then bill it as 'fully modular'. These procs are an absolute nightmare to maintain because once something changes upstream you have to update the overridden proc.</p>
<p>Sometimes you aren't even aware the override exists if it compiles fine and doesn't cause any bugs. This often causes features that were added upstream to be missing here. So yeah. Avoid that. It's okay if something isn't fully modular. Sometimes it's the better choice.</p>
<p>The best candidates for modular proc overrides are ones where you can just tack something on after calling the parent, or weave a parent call cleverly in the middle somewhere to achieve your desired effect.</p>
<p>Performance should also be considered when you are overriding a hot proc (like Life() for example), as each additional call adds overhead. Skyrat edits are much more performant in those cases. For most procs this won't be something you have to think about, though.</p>
<h3 id="these-modular-overrides-should-be-kept-in-and-you-should-avoid-putting-them-inside-modules-as-much-as-possible">These modular overrides should be kept in <code>master_files</code>, and you should avoid putting them inside modules as much as possible.</h3>
<p>To keep it simple, let's assume you wanted to make guns spark when shot, for simulating muzzle flash or whatever other reasons, and you want potentially to use it with all kinds of guns.</p>
<p>You could start, in a modular file, by adding a var.</p>
<pre><code class="language-byond">/obj/item/gun
    var/muzzle_flash = TRUE
</code></pre>
<p>And it will work just fine. Afterwards, let's say you want to check that var and spawn your sparks after firing a shot.
Knowing the original proc being called by shooting is</p>
<pre><code class="language-byond">/obj/item/gun/proc/shoot_live_shot(mob/living/user, pointblank = 0, atom/pbtarget = null, message = 1)
</code></pre>
<p>you can define a child proc for it, that will get inserted into the inheritance chain of the related procs (big words, but in simple cases like this, you don't need to worry)</p>
<pre><code class="language-byond">/obj/item/gun/shoot_live_shot(mob/living/user, pointblank = 0, atom/pbtarget = null, message = 1)
    . = ..() //. is the default return value, we assign what the parent proc returns to it, as we call it before ours
    if(muzzle_flash)
        spawn_sparks(src) //For simplicity, I assume you've already made a proc for this
</code></pre>
<p>And that wraps the basics of it up.</p>
<h3 id="non-modular-changes-to-the-core-code-important">Non-modular changes to the core code - IMPORTANT</h3>
<p>Every once in a while, there comes a time, where editing the core files becomes inevitable.</p>
<p>Please be sure to log these in the module readme.md. Any file changes.</p>
<p>In those cases, we've decided to apply the following convention, with examples:</p>
<ul>
<li>
<p><strong>Addition:</strong></p>
<pre><code class="language-byond">//SKYRAT EDIT ADDITION BEGIN - SHUTTLE_TOGGLE - (Optional Reason/comment)
var/adminEmergencyNoRecall = FALSE
var/lastMode = SHUTTLE_IDLE
var/lastCallTime = 6000
//SKYRAT EDIT ADDITION END
</code></pre>
</li>
<li>
<p><strong>Removal:</strong></p>
<pre><code class="language-byond">//SKYRAT EDIT REMOVAL BEGIN - SHUTTLE_TOGGLE - (Optional Reason/comment)
/*
for(var/obj/docking_port/stationary/S in stationary)
  if(S.id = id)
    return S
*/
//SKYRAT EDIT REMOVAL END
WARNING(&quot;couldn't find dock with id: [id]&quot;)
</code></pre>
<p>And for any removals that are moved to different files:</p>
<pre><code class="language-byond">//SKYRAT EDIT REMOVAL BEGIN - SHUTTLE_TOGGLE - (Moved to modular_skyrat/shuttle_toggle/randomverbs.dm)
/*
/client/proc/admin_call_shuttle()
set category = &quot;Admin - Events&quot;
set name = &quot;Call Shuttle&quot;

if(EMERGENCY_AT_LEAST_DOCKED)
  return

if(!check_rights(R_ADMIN))
  return

var/confirm = alert(src, &quot;You sure?&quot;, &quot;Confirm&quot;, &quot;Yes&quot;, &quot;No&quot;)
if(confirm != &quot;Yes&quot;)
  return

SSshuttle.emergency.request()
SSblackbox.record_feedback(&quot;tally&quot;, &quot;admin_verb&quot;, 1, &quot;Call Shuttle&quot;) //If you are copy-pasting this, ensure the 2nd parameter is unique to the new proc!
log_admin(&quot;[key_name(usr)] admin-called the emergency shuttle.&quot;)
message_admins(span_adminnotice(&quot;[key_name_admin(usr)] admin-called the emergency shuttle.&quot;))
return
*/
//SKYRAT EDIT REMOVAL END
</code></pre>
</li>
<li>
<p><strong>Change:</strong></p>
<pre><code class="language-byond">//SKYRAT EDIT CHANGE BEGIN - SHUTTLE_TOGGLE - (Optional Reason/comment)
//if(SHUTTLE_STRANDED, SHUTTLE_ESCAPE) - SKYRAT EDIT - ORIGINAL
if(SHUTTLE_STRANDED, SHUTTLE_ESCAPE, SHUTTLE_DISABLED)
//SKYRAT EDIT CHANGE END
    return 1
</code></pre>
</li>
</ul>
<h2 id="exceptional-cases-of-modular-code">Exceptional cases of modular code</h2>
<p>From every rule, there's exceptions, due to many circumstances. Don't think about it too much.</p>
<h3 id="defines">Defines</h3>
<p>Due to the way byond loads files, it has become necessary to make a different folder for handling our modular defines.
That folder is <strong><code>code/__DEFINES/~skyrat_defines</code></strong>, in which you can add them to the existing files, or create those files as necessary.</p>
<p>If you have a define that's used in more than one file, it <strong>must</strong> be declared here.</p>
<p>If you have a define that's used in one file, and won't be used anywhere else, declare it at the top, and <code>#undef MY_DEFINE</code> at the bottom of the file. This is to keep context menus clean, and to prevent confusion by those using IDEs with autocomplete.</p>
<h3 id="module-folder-layout">Module folder layout</h3>
<p>To keep form and ensure most modules are easy to navigate and to keep control of the amount of files and folders being made in the repository, you are required to follow this layout.</p>
<p>Ensure the folder names are exactly as stated.</p>
<p>Top most folder: module_id</p>
<p><strong>DO NOT COPY THE CORE CODE FILE STRUCTURE IN YOUR MODULE!!</strong></p>
<p><strong>Code</strong>: Any .DM files must go in here.</p>
<ul>
<li>Good: /modular_skyrat/modules/example_module/code/disease_mob.dm</li>
<li>Bad: /modular_skyrat/modules/example_module/code/modules/antagonists/disease/disease_mob.dm</li>
</ul>
<p><strong>Icons</strong>: Any .DMI files must go in here.</p>
<ul>
<li>Good: /modular_skyrat/modules/example_module/icons/mining_righthand.dmi</li>
<li>Bad: /modular_skyrat/modules/example_module/icons/mob/inhands/equipment/mining_righthand.dmi</li>
</ul>
<p><strong>Sound</strong>: Any SOUND files must go in here.</p>
<ul>
<li>Good: See above.</li>
<li>Bad: See above.</li>
</ul>
<p>The readme should go into the parent folder, module_id.</p>
<p><strong>DO NOT MIX AND MATCH FILE TYPES IN FOLDERS!</strong></p>
<h3 id="commenting-out-code-dont-do-it">Commenting out code - DON'T DO IT</h3>
<p>If you are commenting out redundant code in modules, do not comment it out, instead, delete it.</p>
<p>Even if you think someone is going to redo whatever it is you're commenting out, don't, gitblame exists for a reason.</p>
<p>This also applies to files, do not comment out entire files, just delete them instead. This helps us keep down on filebloat and pointless comments.</p>
<p><strong>This does not apply to non-modular changes.</strong></p>
<h2 id="modular-tgui">Modular TGUI</h2>
<p>TGUI is another exceptional case, since it uses javascript and isn't able to be modular in the same way that DM code is.
ALL of the tgui files are located in <code>/tgui/packages/tgui/interfaces</code> and its subdirectories; there is no specific folder for Skyrat UIs.</p>
<h3 id="modifying-upstream-files">Modifying upstream files</h3>
<p>When modifying upstream TGUI files the same rules apply as modifying upstream DM code, however the grammar for comments may be slightly different.</p>
<p>You can do both <code>// SKYRAT EDIT</code> and <code>/* SKYRAT EDIT */</code>, though in some cases you may have to use one over the other.</p>
<p>In general try to keep your edit comments on the same line as the change. Preferably inside the JSX tag. e.g:</p>
<pre><code class="language-js">&lt;Button
	onClick={() =&gt; act('spin', { high_quality: true })}
	icon=&quot;rat&quot; // SKYRAT EDIT ADDITION
&lt;/Button&gt;
</code></pre>
<pre><code class="language-js">&lt;Button
	onClick={() =&gt; act('spin', { high_quality: true })}
	// SKYRAT EDIT ADDITION START - another example, multiline changes
	icon=&quot;rat&quot;
	tooltip=&quot;spin the rat.&quot;
	// SKYRAT EDIT ADDITION END
&lt;/Button&gt;
</code></pre>
<pre><code class="language-js">&lt;SomeThing someProp=&quot;whatever&quot; /* it also works in self-closing tags */ /&gt;
</code></pre>
<p>If that is not possible, you can wrap your edit in curly brackets e.g. </p>
<pre><code class="language-js">{/* SKYRAT EDIT ADDITION START */} 
&lt;SomeThing&gt;
	someProp=&quot;whatever&quot;
&lt;/SomeThing&gt;
{/* SKYRAT EDIT ADDITION END */}
</code></pre>
<h3 id="creating-new-tgui-files">Creating new TGUI files</h3>
<p><strong>IMPORTANT! When creating a new TGUI file from scratch, please add the following at the very top of the file (line 1):</strong></p>
<pre><code class="language-js">// THIS IS A SKYRAT UI FILE
</code></pre>
<p>This way they are easily identifiable as modular TGUI .tsx/.jsx files. You do not have to do anything further, and there will never be any need for a Skyrat edit comment in a modular TGUI file.</p>
<h2 id="exemplary-prs">Exemplary PR's</h2>
<p>Here are a couple PR's that are great examples of the guide being followed, reference them if you are stuck:</p>
<ul>
<li><a href="https://github.com/Skyrat-SS13/Skyrat-tg/pull/241">https://github.com/Skyrat-SS13/Skyrat-tg/pull/241</a></li>
<li><a href="https://github.com/Skyrat-SS13/Skyrat-tg/pull/111">https://github.com/Skyrat-SS13/Skyrat-tg/pull/111</a></li>
</ul>
<h2 id="afterword">Afterword</h2>
<p>It might seem like a lot to take in, but if we remain consistent, it will save us a lot of headache in the long run, once we start having to resolve conflicts manually.
Thanks to a bit more scrupulous documentation, it will be immediately obvious what changes were done and where and by which features, things will be a lot less ambiguous and messy.</p>
<p>Best of luck in your coding. Remember that the community is there for you, if you ever need help.</p></td></tr></table></main><footer>tgstation.dme <a href="https://github.com/Skyrat-SS13/Skyrat-tg/tree/e507f9120bb0c3beecfe169d14193d90e7229a58">e507f91</a> (master) â€” <a href="https://github.com/SpaceManiac/SpacemanDMM/blob/master/crates/dmdoc/README.md">dmdoc 1.9.0</a></footer></body></html>